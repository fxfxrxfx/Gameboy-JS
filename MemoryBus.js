/**
Gameboy has an address space of 64k. Divided id:
[0000-7FFF] ROM: Game loaded. Divided in:
ROM0: Static. Redirects to game base.
ROM1: Has memory banks, that can be exchange using "Memory banking"
[0000-00FF] BOOT ROM / BIOS: Cleans RAM, writes Nintendo logo, plays "GAMEBOY" sound.
[0100-014F] Header: Points to header with metadata of the game (Game, reqs, etc).
[8000-9FFF] Video RAM: Sprites and backgrounds.
[A000-BFFF] External RAM: Optional. Points to RAM's chip from the game.
[C000-DFFF] Work RAM: 8k. Internal RAM of the console. Can be read and written.
[E000-FDFF] "Mirror" zone: These addresses points to Work RAM. It's not convenient their use.
[FE00-FFFF] Have some subdivs:
[FE00-FE9F] OAM (Object Attribute Memory) RAM: Saves properties of sprites (Position, transparency, etc).
[FEA0-FEFF] Reserved. Not used for devs.
[FF00-FF7F] I/O: Controls input and outpus
[FF80-FFFE] High RAM: Fastest RAM. 
[FFFF] System interruptions.
 */
class MemoryBus {
    constructor(){
        this.inbios = true;
        //Memory
        //LOAD BIOS
        this.bios = this.loadBios();
        this.rom = new Uint8Array(ROM0_MEMORY_SIZE + ROMX_MEMORY_SIZE);
        this.memory = new Uint8Array(0xFFFF);
        this.gpu = new GPU();
        this.wram = new Uint8Array(WRAM_MEMORY_SIZE + WRAMX_MEMORY_SIZE);
    }

    loadProgram(data) {
        for (let i = 0x0100; i < 0x3FFF; i++){
            const instruction = data[i];
            this.memory[i] = instruction
            // console.log("Instruction:", instruction.toString(16));
        }
        
        this.name = "";
        for (var index = 0x134; index < 0x13F; index++) {
            if (this.memory[index] > 0) {
                this.name += String.fromCharCode(this.memory[index]);
            }
        }
    }

    readByte(address){
        switch(address & 0xF000){
            //Case for BIOS address. Once BIOS has run, this memory becomes addressable and BIOS is "removed".
            case 0x0000:{
                if(this.inbios){
                    if( address < 0x0100 ) return this.bios[address]; //If i'm in BIOS addresses still, return that instruction at that address
                    if( this.pc == 0x0100 ) this.inbios = false;    //Else, take me out from bios
                } else {
                    return this.rom[address];
                }
            }

            //ROM BANK 0
            case 0x1000: case 0x2000: case 0x3000:
                return this.rom[address];

            //ROM BANK 1
            case 0x4000: case 0x5000: case 0x6000: case 0x7000:
                return this.rom[address];

            //VRAM
            case 0x8000: case 0x9000:
                return this.gpu.getInstruction(address - VRAM_START);

            default:
                throw "TODO: ... ";
            
        }
    }

    readWord(address){
        return this.readByte(address + 1) << 8  | this.readByte(address);
    }

    /**
     * Writes an 8bit value at an address
     * @param  address 
     * @param  value 
     */
    writeByte(address, value) {
        switch(address & 0xF000) {
            case 0x0000:{
                if(this.inbios && address < 0x0100) return;
            }
            //ROM BANK 0
            case 0x1000: case 0x2000: case 0x3000:
                this.rom[address] = value;

            //ROM BANK 1
            case 0x4000: case 0x5000: case 0x6000: case 0x7000:
                this.rom[address] = value;

            //VRAM
            case 0x8000: case 0x9000:
                return this.gpu.setInstruction(address - VRAM_START);

            default:
                throw "TODO: ... ";
        }
    }

    /**
     * Writes 2 bit integers in memory with the address passed in @param address
     * [...address: value ( 0xFF ), address + 1 : ( value >> 8 ) ( 0xFF ) ]
     * Example: Word 0xABCD in address 0xA000.
     * [0xA000: CD, 0xA001: AB]
     * @param address 
     * @param value 
     */
    writeWord(address, value){
        this.writeByte(address, value & 0xFF);
        this.writeByte(address + 1, (value & 0xFF) >> 8);
    }

    loadBios(){
        return new Uint8Array([0x31, 0xFE, 0xFF, 0xAF, 0x21, 0xFF, 0x9F, 0x32, 0xCB, 0x7C, 0x20, 0xFB, 0x21, 0x26, 0xFF, 0x0E,
            0x11, 0x3E, 0x80, 0x32, 0xE2, 0x0C, 0x3E, 0xF3, 0xE2, 0x32, 0x3E, 0x77, 0x77, 0x3E, 0xFC, 0xE0,
            0x47, 0x11, 0x04, 0x01, 0x21, 0x10, 0x80, 0x1A, 0xCD, 0x95, 0x00, 0xCD, 0x96, 0x00, 0x13, 0x7B,
            0xFE, 0x34, 0x20, 0xF3, 0x11, 0xD8, 0x00, 0x06, 0x08, 0x1A, 0x13, 0x22, 0x23, 0x05, 0x20, 0xF9,
            0x3E, 0x19, 0xEA, 0x10, 0x99, 0x21, 0x2F, 0x99, 0x0E, 0x0C, 0x3D, 0x28, 0x08, 0x32, 0x0D, 0x20,
            0xF9, 0x2E, 0x0F, 0x18, 0xF3, 0x67, 0x3E, 0x64, 0x57, 0xE0, 0x42, 0x3E, 0x91, 0xE0, 0x40, 0x04,
            0x1E, 0x02, 0x0E, 0x0C, 0xF0, 0x44, 0xFE, 0x90, 0x20, 0xFA, 0x0D, 0x20, 0xF7, 0x1D, 0x20, 0xF2,
            0x0E, 0x13, 0x24, 0x7C, 0x1E, 0x83, 0xFE, 0x62, 0x28, 0x06, 0x1E, 0xC1, 0xFE, 0x64, 0x20, 0x06,
            0x7B, 0xE2, 0x0C, 0x3E, 0x87, 0xF2, 0xF0, 0x42, 0x90, 0xE0, 0x42, 0x15, 0x20, 0xD2, 0x05, 0x20,
            0x4F, 0x16, 0x20, 0x18, 0xCB, 0x4F, 0x06, 0x04, 0xC5, 0xCB, 0x11, 0x17, 0xC1, 0xCB, 0x11, 0x17,
            0x05, 0x20, 0xF5, 0x22, 0x23, 0x22, 0x23, 0xC9, 0xCE, 0xED, 0x66, 0x66, 0xCC, 0x0D, 0x00, 0x0B,
            0x03, 0x73, 0x00, 0x83, 0x00, 0x0C, 0x00, 0x0D, 0x00, 0x08, 0x11, 0x1F, 0x88, 0x89, 0x00, 0x0E,
            0xDC, 0xCC, 0x6E, 0xE6, 0xDD, 0xDD, 0xD9, 0x99, 0xBB, 0xBB, 0x67, 0x63, 0x6E, 0x0E, 0xEC, 0xCC,
            0xDD, 0xDC, 0x99, 0x9F, 0xBB, 0xB9, 0x33, 0x3E, 0x3c, 0x42, 0xB9, 0xA5, 0xB9, 0xA5, 0x42, 0x4C,
            0x21, 0x04, 0x01, 0x11, 0xA8, 0x00, 0x1A, 0x13, 0xBE, 0x20, 0xFE, 0x23, 0x7D, 0xFE, 0x34, 0x20,
            0xF5, 0x06, 0x19, 0x78, 0x86, 0x23, 0x05, 0x20, 0xFB, 0x86, 0x20, 0xFE, 0x3E, 0x01, 0xE0, 0x50]);
    }
}
